
## 说明
- 在处理大量并发任务的时候，如果按照传统的方式，一个请求一个线程来处理任务，大量的
  线程创建和销毁将消耗过多的系统资源，还增加了线程上下文的开销，而这些问题可以通过
  线程池技术解决。
- 线程池技术通过在系统中预先创建一定数量的线程，当任务请求到来时，从线程池中分配一
  个预先创建的线程去处理任务，线程在处理完任务之后还可以重用，不会销毁，而是等待下
  次任务的到来。
- 通过线程池能避免大量的线程创建和销毁动作，从而节省系统资源，这样做的一个好处是，
  对于多核处理器，由于线程会被分配到多个CPU，会提高并行处理效率。另一个好处是每个
  线程独立阻塞，可以防止主线程被阻塞而使主流程被阻塞，导致其他请求得不到响应。

## 具体实现
- 主要成员是一个线程数组和一个任务队列，在未运行(未调用 ThreadPool_run)之前，二者并没
  有任何关联，所以 ThreadPool_init 和 ThreadPool_addTask 调用顺序并不做具体要求。
- 为了确保不同线程调用 ThreadPool_run 或 ThreadPool_addTask 对任务队列生产消费的幂等
  性(一个任务只被处理一次)，定义了不同线程之间的同步锁与条件脉冲。
- 定义 std::once_flag 变量，确保执行完毕后，对所有线程的销毁只执行一次
- 示例程序: realize.cpp

## 注意
- 主线程并不会执行任务处理，在创建子线程完毕后，主线程应该挂起，等待任务执行完毕。
- 生产上，作为一个服务，线程池应该是一直在运行着的，即使任务队列为空。
